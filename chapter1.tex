\documentclass[lambda.tex]{subfiles}
\begin{document}

\paragraph{Введение} ~\\

В 1928 году Давид Гильберт сформулировал так называемую проблему разрешимости, суть которой примерно выражается в следующем. Было необходимо сформулировать такой алгоритм, который на основании формального языка и утверждения, записанного этим языком, поданных на вход, за конечное число шагов приходил к ответу, является это утверждение ложным или истинным. В 1936 году два математика, Алонзо Чёрч и Алан Тьюринг независимо друг от друга опубликовали работы, в которых заявлялось, что для арифметических утверждений такой алгоритм составить невозможно, а потому и в более общем случае эта проблема неразрешима. Впоследствие это утверждение стало известно как теорема Чёрча-Тьюринга и породило как минимум два средства формализации алгоритмов и понятия вычислимости. В случае с Аланом Тьюрингом это была небезызвестная машина Тьюринга. В случае с Алонзо Чёрчем это было лямбда исчсиление. Итак, что же это такое? Для начала опишем его.

Основными объектами лямбда исчисления являются функции. Но что же мы понимаем под функциями? В современной математике под функцией $f$ чаще всего понимают некоторое соответствие элементам области определения $X$ элементов области значения $Y$, то есть для каждой $f:X \rightarrow Y$ верно, что $f \subseteq X \times Y$. Тем не менее, лямбда исчисление - это теория функций как формул. Это система, позволяющая работать с функциями как с выражениями.
Давайте для начала вспомним другой хорошо известный язык выражений, арифметику. Арифметические выражения составляются из переменных ($x,y,z\dots$), чисел ($1,2,3\dots$), и операторов ($``+'',``-'',``\times''\text{etc.}$). Выражение вроде $x+y$ представляет из себя \emph{результат} сложения. Главное преимущество этого языка в том, что выражения можно вкладывать одно в другое, не указывая отдельно промежуточные результаты. Так, например, мы пишем
\[A=(x+y) \times z^2\]
а не
\[\text{Пусть }w=x+y\text{, тогда пусть }u=z^2 \text{, тогда пусть }A=w \times u\]
Использование второго варианта было бы утомительным и неудобным.
Лямбда исчисление расширяет идею языка выражений на функции. Так вместо выражения вида
\[\text{Пусть } f \text{ функция } x \mapsto x^2 \text{. Тогда будем считать, что } A=f(5)\]
в лямбда исчислении мы просто пишем
\[A=(\lambda x.x^2)(5)\]
Выражение $\lambda x.x^2$ выражает функцию, которая ставит в соответствие прообразу $x$ образ $x^2$. Как и в арифметике, мы используем скобки, чтобы группировать термы.

\newpage
\paragraph{Формализация}~\\

Множество лямбда-термов строится из бесконечного множества переменных $\mathcal{V}$ использованием аппликации и абстракции:
\[\mathcal{V} = \{ v, v', v'', v''' \dots \}\]

При этом, говоря формально:
\begin{align*}
	x \in \mathcal{V} & \implies x \in \Lambda &\text{(Переменная является лямбда-термом)}\\
	M, N \in \mathcal{V} & \implies M N \in \Lambda &\text{(Аппликация является лямбда-термом)}\\
	M \in \mathcal{V}, v \in \mathcal{V} & \implies \lambda v.M \in \Lambda &\text{(Абстракция является лямбда-термом)}
\end{align*}

Или же, используя БНФ:
\begin{align*}
		  V &::= v|V'\\
	\Lambda &::= V | (\Lambda\ \Lambda) | ( \lambda V . \Lambda )
\end{align*}

В дальнейшем условимся, что:
\begin{itemize}
	\item\(x,y,z,\dots - \text{произвольные переменные.}\)
	\item\(M,N,L,\dots - \text{произвольные лямбда термы.}\)
	\item Скобки верхнего уровня опускаются.
	\item Аппликация правоассоциативна, т.е.\\
		\[F\ M_1 \ M_2 \ \dots\ M_n \equiv (\dots((F\ M_1)\ M_2)\ \dots\ M_n)\]
	\item Допустима абстракция сразу по нескольким переменным
		\[\lambda x_1 \ x_2 \ \dots\ x_n .M \equiv \lambda x_1 .(\lambda x_2 .\ \dots\ (\lambda x_n .M))\]
\end{itemize}

\newpage
\paragraph{Свободные и связанные переменные} % (fold)
\label{par:free_and_bound} ~\\

Множество свободных переменных терма $N$ обозначается $FV(N)$ и индуктивно определяется по следующим правилам:
\begin{align*}
	FV(x) 			&\equiv \{x\}\\
	FV(M\ N) 		&\equiv FV(M)\cup FV(N)\\
	FV(\lambda x.N) &\equiv FV(N)\setminus\{x\}
\end{align*}

Мы будем называть переменную связанной, если она не принадлежит множеству свободных. Множество связанных переменных терма $N$ принято обозначать как $BV(N)$ Заметим, что переменная связана, если она образует абстракцию.

Аналогично можно определить $BV(F)$ индуктивно:
\begin{align*}
	BV(x) 			&\equiv \{\varnothing\}\\
	BV(M\ N) 		&\equiv BV(M)\cup BV(N)\\
	FV(\lambda x.N) &\equiv BV(N)\cup\{x\}
\end{align*}

Мы будем называть терм $M$ закрытым (или комбинатором), если\\ \(FV(M) \equiv \varnothing\). Множество комбинаторов обозначим как $\Lambda^\circ$. Существует раздел математики, тесно связанный с $\lambda$-исчислением - комбинаторная логика. Она изучает комбинаторы и вычисления, построенные на них. В комбинаторной логике вводится несколько стандартных комбинаторов:

\begin{align*}
	&\boldsymbol{S}xyz = xz(yz)\\
	&\boldsymbol{K}xy = x\\
    &\boldsymbol{I}x = x\\
	% TODO: больше комбинаторов Богу комбинаторов!
\end{align*}
% \begin{tcolorbox}
% 	Комбинаторная логика не является основной темой данного пособия. Тем не менее, даже этого краткого знакомства достаточно, чтобы решить задачи /номера задач/ в приложении.
% \end{tcolorbox}

%TODO: task: дать определение комбинаторам лямбда термами, выразить I через S и K

% paragraph свободные_и_связанные_переменные (end)
\newpage
\paragraph{$\boldsymbol{\alpha}$-конверсия} % (fold)
\label{par:aplha conversion} ~\\

Введем на $\Lambda$ отношение эквивалентности, задаваемое следующим образом:
\begin{align*}
	\forall P.P &=_\alpha P\\
	\lambda x.P &=_\alpha \lambda y.P[x:=y] \text{, если } y \not\in FV(P)
\end{align*}

Это отношение назвается $\alpha$-эквивалентностью. Также запишем некоторые аксиомы для него:

\begin{align*}
	M &=_\alpha M\\
	M =_\alpha N &\Rightarrow N =_\alpha M\\
	M =_\alpha N, N =_\alpha L &\Rightarrow M =_\alpha L\\
	M =_\alpha M' &\Rightarrow M\ Z =_\alpha M'\ Z\\
	M =_\alpha M' &\Rightarrow Z\ M =_\alpha Z\ M'\\
	M =_\alpha M' &\Rightarrow \lambda x.M =_\alpha \lambda x.M'
\end{align*}

Если $M =_\alpha N$, иногда также пишут $\lambda\models M =_\alpha N$

%TODO: перепилить как правила вывода

Обобщая определения выше, термы $M$ и $N$ равны (альфа-эквивалентны), если можно получить один из другого, путем замены имен связанных переменных. Любые два равных терма в одинаковом контексте также будут равны.
%Это так ты про альфа-эквивалентность коротко? Вот пидор.
%[Д] Тип да. Так лучше?
%[В] Дыа. Вот только про контекст без разъяснения могут докопаться.
%[Д] Сам бери и определяй контекст, можно в Беренгара заглянуть.

Сам процесс замены имени называется $\alpha$-конверсией и определяется следующим образом:
\begin{equation*}
	\lambda x.M \rightarrow_\alpha \lambda y.(M[x := y]) \text {, если } y \not\in FV(M)\tag{$\alpha$}
\end{equation*}
% запили как с бетой
% DONE

Все утверждения о термах дальше рассматриваются с точностью до $\alpha$-конверсии. Если написано, что термы равны или эквивалентны это означает, что они $\alpha$-эквивалентны.

% paragraph aplha conversion (end)
\newpage
\paragraph{Подстановки} % (fold)
\label{par:substitution}~\\

Результат подстановки $N$ вместо всех свободных вхождений $x$ в $M$ обозначим $M[x := N]$ и определим как:
\begin{align*}
	x[x := N] &\equiv N\\
	y[x := N] &\equiv y\ (\text{если } x \neq y)\\
	(M_1 \ M_2 )[x := N] &\equiv ((M_1 [x := N])\ (M_2 [x := N]))\\
	(\lambda y.M)[x := N] &\equiv (\lambda y.M[x := N])
\end{align*}

%TODO: Что-то про Variable convention

Условимся, что подстановка всегда выполняется корректно, то есть заменяемая переменная никогда не является связанной ни в каких внутренних термах. Этой ситуации всегда можно избежать заменой имен во внутреннем терме. Например для следующей подстановки предварительно произведем замену имени во внутреннем терме
\[\lambda a.\lambda b.a\ b[a := b] = \lambda a.(\lambda b.a\ b[b := b'])[a := b] = \lambda b.\lambda b'.b\ b'\]

В силу этого условия допускается некая вольность в обращении с подстановкой, что делает рассуждения компактнее без ущерба сути, пусть и с меньшей долей формализма.

% paragraph substitution (end)

Теперь мы готовы описать $\lambda$-исчисление как формальную теорию.

\newpage
\paragraph{$\beta$-редукция} % (fold)
\label{par:beta reduction}~\\

Основная схема $\lambda$-исчисления
\begin{equation*}
	\forall M, N \in \Lambda : (\lambda x.M)\ N = M[x := N]\tag{$\beta$}
\end{equation*}

Используя аксиому ($\beta$), сформулируем несколько служебных лемм:
\begin{lemma}{о множественной подстановке}
	\[(\lambda x_1 \ x_2 \ \dots\ x_n .M)\ X_1 \ X_2 \ \dots\ X_n \equiv M[x_1 := X_1 ][x_2 := X_2]\dots[x_n := X_n ]\]
\end{lemma}
\begin{proof}
	Пусть $M' = \lambda x_2 \dots x_n .M$. По аксиоме $(\beta)$ мы имеем
	\[(\lambda x_1 .M')\ X_1 \ X_2 \ \dots\ X_n \equiv M'[x_1 := X_1 ] X_2 \ \dots\ X_n\]
	Дальнейшее равенство получаем индукцией по связанным переменным.
\end{proof}

Первую лемму стоит воспринимать, как аппликацию для функции нескольких переменных. Конечно, всегда можно перейти от функции нескольких переменных к функции одной переменной, используя каррирование (частичную подстановку).

\begin{lemma}{о порядке подстановки}
	\[M[x := N_1][y := N_2] \equiv M[y := N_2][x := N_1[y := N_2]]\]
\end{lemma}
\begin{proof}
	Индукция по структуре терма M: \\
	\begin{itemize}
		\item M $\in$ $\mathcal{V}$ По определению подстановки имеем три случая
		\begin{itemize}
		% TODO: стрелка => !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		% [В] DONE
		 	\item $M = x \implies N_1[y := N_2] \equiv N_1[y := N_2]$
		 	\item $M = y \implies N_2 \equiv N_2$ ($x\not\in FV(N_2)$)
		 	\item $M = z$ ($z \neq x, y$) $\implies z \equiv z$
		 \end{itemize}
		 \item M = $\lambda z.M_1$
		 В силу соглашений, можно предположить, что $z \neq x,y$ и $z\not\in FV(N_1) \cup FV(N_2)$
		 \begin{align*}
		 	(\lambda z.M_1)[x := N_1][y := N_2] &\equiv \lambda z.M_1[x := N_1][y := N_2]\\
		 										&\equiv \lambda z.M_1[y := N_2][x := N_1[y := N_2]] \\
		 										&\equiv (\lambda z.M_1)[y := N_2][x := N_1[y := N_2]]
		 \end{align*}
		 Второе равенстро полученно из индукционного предположения
		 \item $M = M_1 M_2$
		 По индукции лемма верна для $M_1$ и $M_2$, далнейшее равенство очевидно
	\end{itemize}
\end{proof}

% TODO:
% Одно ли применение есть beta-редукция
Однократное применение аксиомы ($\beta$) будем называть $\beta$-редукцией и обозанчать как ($\rb$). Место, где можно применить аксиому ($\beta$) будем называть редексом. 
Применение аксиомы ($\beta$) ноль или более раз обозначим как $\rbm$ (транзитивное замакание $\rb$)

Также введем отношение $\beta$-эквивалентности, которое обозначим как $=_\beta$
%TODO: корректность этой фигни
% TODO(В): Действительно описать бета-эквивалентность

Любое вычисление представляет собой некоторое количество шагов $\beta$-редукции.

Вычисления заканчиваются, когда в терме не остается редексов. Будем говорить, что такие термы находятся в нормальной форме.

Стоит заметить, что $\beta$-редукция, хотя и называется редукцией, не всегда сокращает терм, и тем более, не всегда делает терм проще. В качестве примера выражения, которое не сокращается при применении $\beta$-редукции, можно привести следующий терм:
\begin{equation*}
	\omega = (\lambda x.xx)\ (\lambda x.xx)
\end{equation*}

Такая конструкция за один шаг редуцируется в себя. Очевидно, что у $\omega$ никакая цепочка преобразований не приведет к нормальной форме, но тогда возникают вопросы, для каких термов существует нормальная форма, зависит ли она от порядка применения ($\beta$) и любой ли порядок редукции ведет к нормальной форме. Мы вернемся к этой теме позже, а пока дополним наше $\lambda$-исчисление еще одной аксиомой
\begin{equation*}
	\lambda x.Mx \equiv M \text{ если }x \not\in FV(M) \tag{$\eta$}
\end{equation*}
% Не, ну что-нибудь про эта-эквивалентность, а?

% paragraph beta reduction (end)
\newpage
\paragraph{Неподвижная точка} % (fold)
\label{par:fix point}~\\

На данном этапе мы можем относительно свободно строить различные термы, однако особый подход требуется для описания рекурсивных функций, о чем сейчас и пойдет речь. Для бестипового лямбда-исчисления справедлива следующая теорема:
% [Теорема о неподвижной точке]
\newtheorem*{fixpoint}{Теорема о неподвижной точке}
\begin{fixpoint}
\begin{align*}
	&(i)\ \ \forall F. \exists X. (F\ X = X) \\
	&\text{Более того, существует комбинатор, находящий $X$}\\
	% &\text{}\\
	&\ \ \ \ \ \boldsymbol{Y} = \lambda f.(\lambda x.f\ (x\ x)) (\lambda x.f\ (x\ x))\\
	&(ii)\ \forall F.(\boldsymbol{Y}\ F=F\ (\boldsymbol{Y}\ F))
\end{align*}
\end{fixpoint}

\begin{proof}~\\
Определим $W = \lambda x.F(x\ x)$ и $X = W\ W$ тогда
\begin{align*}
	X \equiv W\ W \equiv (\lambda x.F(x\ x))W \rightarrow_\beta\\
	F\ (W\ W) \equiv F X
\end{align*}
Аналогично
\begin{align*}
	&\boldsymbol{Y}\ F \rightarrow_\beta\\
	&(\lambda x.F\ (x\ x)) (\lambda x.F\ (x\ x)) \rightarrow_\beta\\
	&F\ ((\lambda x.F\ (x\ x)) (\lambda x.F\ (x\ x))) \equiv F\ (\boldsymbol{Y}\ F)
\end{align*}
\end{proof}
% paragraph fix point (end)

\newpage
\paragraph{Нормальный и аппликативный порядки редукции} % (fold)
\label{par:lazy and energic reduction}~\\

Как вы уже видели, не все термы имеют нормальную форму. Рассмотрим следующий терм:
\begin{equation*}
	N = (\lambda x y.y)\ ((\lambda x.xx)(\lambda x.xx))\ M
\end{equation*}
В этом терме два редекса, можно произвести $\beta$-редукцию в двух разных местах:
\begin{align*}
	N &\rb M\\
	N &\rb (\lambda x y.y) ((\lambda x.xx)(\lambda x.xx)) M
\end{align*}
В первом случае мы проредуцировали внешний редекс, во втором внутренний (который оказался уже знакомым термом $\omega$, редуцирующимся в себя). Как вы могли заметить, мы не сможем придти к нормальной форме $N$, редуцируя внутренний терм, когда как единственная редукция внешнего терма приводит $N$ к его нормальной форме. Это значит, что если нормальная форма существует, к ней не обязательно ведет любой порядок редукции. То, в каком порядке мы производим редукцию, определяет стратегию вычислений. Выделяют различные стратегии, мы же затронем две из них: аппликативную (соответствующую энергичным вычислениям в языках программирования) и нормальную (она соответствует ленивым вычислениям).

При аппликативной стратегии, мы редуцируем термы справа нелево, изнутри наружу. Это соответствует вычислению значения аргументов перед вызовом функции.

Нормальная стратегия предполагают редукцию слева направо, снаружи внутрь. Это соответствует отказу от вычисления значений агрументов перед вызовом функции

Существует утверждение(Карри) о том, что если у терма существует нормальная форма, то к ней можно придти при помощи ленивой стратегии вычислений. Не будем приводить доказательство этого факта ввиду его трудоемкости. 

\begin{tcolorbox}
	\paragraph{Теорема Чёрча-Россера} % (fold)
	\label{par:Church-Rosser}~\\
	Мы подошли к центральному моменту в $\lambda$-исчислении. Часть вещей, описанных ранее, которые принимались как должное можно обосновать используя теорему, приведенную ниже. В какой-то мере, эта теорема обосновывает все наши допущения о корректности исчисления.
	\newtheorem*{churchrosser}{Теорема Чёрча-Россера (CR)}
	\begin{churchrosser}
		$$
		\forall M,N_1,N_2:M
		\rbm N_1, M
		\rbm N_2
		\implies
		\exists N : N_1
		\rbm N,N_2
		\rbm N
		$$
		Иначе говоря, для $\beta$-редукции выполняется свойство ромба
		\begin{align*}
			\xymatrix{
			& \ar@{->>}[dl]_\beta M \ar@{->>}[dr]^\beta \\
			N_2 \ar@{->>}[dr]^\beta & & N_1 \ar@{->>}[dl]_\beta \\
			&N
		}
		\end{align*}
	\end{churchrosser}


	\begin{corollary}[Единственность нормальной формы]
		~\\
		Пусть $N_1$ и $N_2$ - нормальные формы терма $N$. Тогда $N_1 = N_2$ 
	\end{corollary}
	\begin{proof}
		По теореме CR $$\exists M.N_1 \rbm M, N_2 \rbm M$$
		Из определения нормальной формы, термы $N_1$ и $N_2$ не имеют редексов.
		$\implies$ $M=N_1$ и $M=N_2$ $\implies N_1 = N_2$
	\end{proof}
	\begin{corollary}
		Если $M =_\beta N$ и при этом один из термов имеет нормальную форму $Z$, второй также нормализуем, причем его нормальная форма равна $Z$
	\end{corollary}
	\begin{proof}
		Не умоляя общности, пусть $Z$ - нормальная форма $M$, тогда 
		$$M \rbm Z \implies M =_\beta Z \implies N =_\beta Z \implies N \rbm Z$$
		Последнее следствие допустимо ввиду того, что $Z$ не имеет редексов
	\end{proof}
	\begin{corollary}
		$\eta$-редукция не следует из ($\beta$)
		~\\
		$\lambda x.y\ x \neq_\beta y$
	\end{corollary}
	\begin{proof}
		Термы $y$ и $\lambda x.y\ x$ находятся в нормальной форме, при этом $\lambda x.y\ x \neq_\alpha y$, а значит, $\lambda x.y\ x \neq_\beta y$ (ввиду единственности нормальной формы)
	\end{proof}
	% paragraph Church-Rosser (end)
\end{tcolorbox}

\end{document}
