\documentclass[lambda.tex]{subfiles}
\begin{document}

\newcommand{\mmnot}{\text{\textbf{not}}}
\newcommand{\mmand}{\text{\textbf{and}}}
\newcommand{\mmor}{\text{\textbf{or}}}
\newcommand{\mmif}{\text{\textbf{if}}}
\newcommand{\mmt}{\text{\textbf{True}}}
\newcommand{\mmf}{\text{\textbf{False}}}
\newcommand{\mmterm}[1]{\text{\textbf{#1}}}
\newcommand{\mmchurchn}[1]{\boldsymbol{\bar{#1}}}

Поговорим о лямбда-исчислении со стороны программирования. Для начала построим булеву алгебру на лямбда исчислении.

Пусть \textbf{True} и \textbf{False} некие лямбда термы, при этом $\mmt \neq_\beta \mmf$. Один из возможных способов сделать это следующий

\begin{align*}
\mmt = \lambda a b.a\\
\mmf = \lambda a b.b
\end{align*}

Определим также термы \textbf{and}, \textbf{or} и \textbf{not}, представляющие соответсвующие операции

\begin{align*}
&\mmand = \lambda t_1 t_2 a b . (t_1 (t_2 a b) b)\\
&\mmor = \lambda t_1 t_2 a b.(t_1 a (t_2 a b))\\
&\mmnot = \lambda f a b . f b a
\end{align*}

Доходчивый читатель сам удостоверится, что такие определения удовлетворяют аксиомам булевой алгебры.
Мы можем проверить различные свойства булевой алгебры, к примеру проверим инволюцию отрицания

\begin{align*}
	\mmnot\ \mmnot\ x \rb
	\mmnot\ \lambda a' b' . x b' a' \rb
	\lambda a'' b'' . (\lambda a' b' . a b' a') b'' a'' \rbm
	\lambda a'' b'' . x a'' b'' \equiv x
\end{align*}

Стоит также упомянуть условную конструкцию if
\begin{align*}
	&\mmif = \lambda t. t\\
	&\mmif\ \mmt\ a\ b \rbm a\\
	&\mmif\ \mmf\ a\ b \rbm b\\
\end{align*}

Следующий пункт - натуральные числа
% --- Нумералы  Чёрча
Определим натуральные числа следующим образом:
\begin{align*}
	&\mmchurchn{0} = \lambda fx.x = \mmterm{const}\\
	&\mmchurchn{1} = \lambda fx.f\ x = \mmterm{id}\\
	&\dots\\
	&\mmchurchn{n} = \lambda f.\lambda x.f^n x\\
	&\text{Где }f^n(x) = \underbrace{f(f(f(\dots f(}_{n\text{ раз}}x))))
\end{align*}

Такое представление чисел назыается нумералами Чёрча
Можно показать, что для них выполняются аксиомы Пеано.

Определим также основные арифметические опперации. 

% Инкремент {Как тут вообще оформить всю фигню}
% succ n == n+1
% succ = λn.λf.λx. f (n f x)
% Данную запись можно трактовать так: мы применяем f n раз и еще один раз, что и эквивалентно увеличению на еденицу для нумералов Чёрча.

% Докажем корректность данного определения:
% succ n ->(β) λf x. f ((λg y. g^n y) f x) ->(β) λf x.f (λy.f^n y) x ->(β) λf x. f (f^n x) == λf x.f^(n+1) x == n+1

% Сложение, умножение и возведение в степень определяются так:
% \begin{align*}
% add = \lambda a b f x. (b f (a f) x)
% mul = \lambda a b f.a (b f)
% exp = \lambda a b.b a
% \end{align*}
% % TODO: задача или описание корректности этого
% % Примеры

% Определить же вычитание значительно сложнее, ведь мы индуктивно строим n-ое число и остановится за m шагов до n задача не тривиальная. Мы могли бы определить вычитание относительно просто через декремент, но как же тогда определить сам декремент?
% Идея решения этой проблеммы заключается в следующем, мы можем инкрементировать число и как-то хранить предыдущий результат (число до инкремента) в конечном итоге мы получим пару из n и (n-1).
% Для реализации этого способа, определим упорядоченную пару как тройку термов
% \begin{align*}
% mkPair = \lambda f a b. f a b
% fst = \lambda p. p True
% snd = \lambda p.p False
% \end{align*}
% mkPair создает пару, а fst и snd получают первый и второй элементы пары соответственно.
% Далее определим \"инкремент\" пары
% $succP = \lambda p. mkPair (snd p) (succ (fst p))$
% Ну а имея эту функцию не составит труда определить декремент
% $prev = \lambda n.fst (n succP (mkPair 0 0))$
% и вычитание

\end{document}