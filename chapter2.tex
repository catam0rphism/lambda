\documentclass[lambda.tex]{subfiles}
\begin{document}

\paragraph{Программирование} % (fold)
\label{par:programming_intro}~\\

Если отойти от вопросов чисто математических, то довольно-таки большой интерес в лямбда-исчислении вызывает тот факт, что оно играет роль некоего прототипного языка программирования.
То есть возможно построить такие термы, которые обеспечат функционал, аналогичный некоторым базовым возможностям языков программирования.
Очевидно, что формировать эти термы стоит от более простых к более сложным, а самая базовая часть программирования - это логические значения и операции над ними.
% paragraph programming_intro (end)

\paragraph{Логические конструкции} % (fold)
\label{par:bolean}
~\\

Пусть \textbf{True} и \textbf{False} некие лямбда термы, при этом $\mmt \neq_\beta \mmf$. Один из возможных способов сделать это следующий

\begin{align*}
\mmt = \lambda a b.a\\
\mmf = \lambda a b.b
\end{align*}

Определим также термы \textbf{and}, \textbf{or} и \textbf{not}, представляющие соответствующие операции

\begin{align*}
&\mmand = \lambda t_1 t_2 a b . (t_1 (t_2 a b) b)\\
&\mmor = \lambda t_1 t_2 a b.(t_1 a (t_2 a b))\\
&\mmnot = \lambda f a b . f b a
\end{align*}

Доходчивый читатель сам удостоверится, что такие определения удовлетворяют аксиомам булевой алгебры.
Мы можем проверить различные свойства булевой алгебры, к примеру проверим инволюцию отрицания

\begin{align*}
	\mmnot\ \mmnot\ x \rb
	\mmnot\ \lambda a' b' . x b' a' \rb
	\lambda a'' b'' . (\lambda a' b' . a b' a') b'' a'' \rbm
	\lambda a'' b'' . x a'' b'' \equiv x
\end{align*}

Стоит также упомянуть условную конструкцию if
\begin{align*}
	&\mmif = \lambda t. t\\
	&\mmif\ \mmt\ a\ b \rbm a\\
	&\mmif\ \mmf\ a\ b \rbm b\\
\end{align*}

% paragraph логические_конструкции (end)
\paragraph{Натуральные числа} % (fold)
\label{par:natural_numbers}
~\\

Следующий пункт - натуральные числа
% --- Нумералы  Чёрча
Определим натуральные числа следующим образом:
\begin{align*}
	&\mmchurchn{0} = \lambda fx.x = \mmterm{const}\\
	&\mmchurchn{1} = \lambda fx.f\ x = \mmterm{id}\\
	&\dots\\
	&\mmchurchn{n} = \lambda f.\lambda x.f^n x\\
	&\text{Где }f^n(x) = \underbrace{f(f(f(\dots f(}_{n\text{ раз}}x))))
\end{align*}

Такое представление чисел называется нумералами Чёрча
Можно показать, что для них выполняются аксиомы Пеано.

Определим также основные арифметические операции. 
Самой простой из арифметических операций является инкремент, то есть получение следующего числа. Попробуем сформулировать это на языке лямбда исчисления.
\begin{align*}
	& \mmterm{succ}\ \mmchurchn{n} = \mmchurchn{n+1}\\
	& \mmterm{succ} = \lambda nfx. f\ (n\ f\ x)
\end{align*}
Данную запись можно трактовать так: мы применяем $f$ $n$ раз и еще один раз, что и эквивалентно увеличению на единицу для нумералов Чёрча.

Докажем корректность данного определения:
\begin{align*}
	\mmterm{succ}\ \mmchurchn{n} \rb\\
	\lambda fx.f\ ((\lambda gy.g^n\ y)\ f\ x) \rb\\
	\lambda fx.f\ (\lambda y.f^n\ y)\ x \rb\\
	\lambda fx.f\ (f^n\ x) \equiv \lambda fx.f^{(n+1)}\ x \equiv \mmchurchn{n+1}\\
	\qedsymbol
\end{align*}

% \begin{tcolorbox}
% Перед дальнейшим ознакомлением с материалом предлагаем вам самостоятельно вывести лямбда-термы для сложения умножения и возведения в степень, решив задачу /номер задачи/ в приложении.
% \end{tcolorbox}
% \newpage
% TODO(В): Что-нибудь получше чем \newpage
Сложение, умножение и возведение в степень определяются так:
\begin{align*}
	&\mmterm{add} = \lambda abfx.(b\ f\ (a\ f)\ x)\\
	&\mmterm{mul} = \lambda abf.a\ (b\ f)\\
	&\mmterm{pow} = \lambda ab.b\ a
\end{align*}
% % TODO: задача или описание корректности этого
% % Примеры

Определить же вычитание значительно сложнее, ведь мы индуктивно строим $n$-ое число и остановка за $m$ шагов до $n$ -- задача не тривиальная. Мы могли бы определить вычитание относительно просто через декремент, но как же тогда определить сам декремент?
Идея решения этой проблемы заключается в следующем, мы можем инкрементировать число и как-то хранить предыдущий результат (число до инкремента) в конечном итоге мы получим пару из $\mmchurchn{n}$ и $\mmchurchn{n-1}$.

Для реализации этого способа, нам необходимо как-то задавать пары. Будем считать парой такой терм, из которого можно получить первый и второй элемент. Очевидно, что нам также понадобится терм, который будет создавать пару из двух других термов. Попробуем описать это в такой форме:
\begin{align*}
	\mmterm{mkPair} = \lambda abf.f\ a\ b\\
	\mmterm{fst} = \lambda p.p\ \mmterm{True}\\
	\mmterm{snd} = \lambda p.p\ \mmterm{False}
\end{align*}
Здесь $\mmterm{mkPair}$ создает пару, а $\mmterm{fst}$ и $\mmterm{snd}$ получают первый и второй элементы пары соответственно. Очевидно также, что получившаяся конструкция задаёт упорядоченные пары, так как мы отличаем первый и второй элемент.

Далее определим ``инкремент'' пары
\[\mmterm{succP} = \lambda p. \mmterm{mkPair}\ (\mmterm{snd}\ p)\ (\mmterm{succ}\ (\mmterm{fst}\ p))\]

Ну, а имея эту функцию не составит труда определить декремент
\[\mmterm{prev} = \lambda n.\mmterm{fst}\ (n\ \mmterm{succP}\ (\mmterm{mkPair}\ \mmchurchn{0}\ \mmchurchn{0}))\]

и вычитание
\[\mmterm{sub} = \lambda ab.b\ \mmterm{prev}\ a\]

% paragraph natural_numbers (end)
\end{document}
