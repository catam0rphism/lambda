\documentclass[lambda.tex]{subfiles}
\begin{document}

\newcommand{\mmnot}{\text{not}}
\newcommand{\mmand}{\text{and}}
\newcommand{\mmor}{\text{or}}
\newcommand{\mmif}{\text{if}}
\newcommand{\mmt}{\text{True}}
\newcommand{\mmf}{\text{False}}

Поговорим о лямбда-исчислении со стороны программирования. Для начала построим булеву алгебру на лямбда исчислении.

Пусть True и False некие лямбда термы, при этом $\mmt \neq_\beta \mmf$ один из возможных способов сделать это следующий

\begin{align*}
\mmt = \lambda a b.a\\
\mmf = \lambda a b.b
\end{align*}

Определим также термы and, or и not, представляющие соответсвующие операции

\begin{align*}
&\mmand = \lambda t_1 t_2 a b . (t_1 (t_2 a b) b)\\
&\mmor = \lambda t_1 t_2 a b.(t_1 a (t_2 a b))\\
&\mmnot = \lambda f a b . f b a
\end{align*}

Доходчивый читатель сам удостоверится, что такие определения удовлетворяют аксиомам булевой алгебры.
Мы можем проверить различные свойства булевой алгебры, к примеру проверим инволюцию отрицания

\begin{align*}
	\mmnot\ \mmnot\ x \rb
	\mmnot\ \lambda a' b' . x b' a' \rb
	\lambda a'' b'' . (\lambda a' b' . a b' a') b'' a'' \rbm
	\lambda a'' b'' . x a'' b'' \equiv x
\end{align*}

Стоит также упомянуть условную конструкцию if
\begin{align*}
&\mmif = \lambda t. t\\
&\mmif\ \mmt\ a\ b \rbm a\\
&\mmif\ \mmf\ a\ b \rbm b\\
\end{align*}

Следующий пункт - натуральные числа
% --- Нумералы  Чёрча
Определим натуральные числа следующим образом:
% 0 == λf x.x == const
% 1 == λf x. f x == id
% ..
% n == λf.λx.f^n x
% Где  f^n(x) == f(f(f(...f(x)))) n раз {тип композиция}  
Такое представление чисел назыается нумералами Чёрча
Можно показать, что для них выполняются аксиомы Пеано.

Определим также основные арифметические опперации. 

% Инкремент {Как тут вообще оформить всю фигню}
% succ n == n+1
% succ = λn.λf.λx. f (n f x)
% Данную запись можно трактовать так: мы применяем f n раз и еще один раз, что и эквивалентно увеличению на еденицу для нумералов Чёрча.

% Докажем корректность данного определения:
% succ n ->(β) λf x. f ((λg y. g^n y) f x) ->(β) λf x.f (λy.f^n y) x ->(β) λf x. f (f^n x) == λf x.f^(n+1) x == n+1

% Сложение, умножение и возведение в степень определяются так:
% \begin{align*}
% add = \lambda a b f x. (b f (a f) x)
% mul = \lambda a b f.a (b f)
% exp = \lambda a b.b a
% \end{align*}
% % TODO: задача или описание корректности этого
% % Примеры

% Определить же вычитание значительно сложнее, ведь мы индуктивно строим n-ое число и остановится за m шагов до n задача не тривиальная. Мы могли бы определить вычитание относительно просто через декремент, но как же тогда определить сам декремент?
% Идея решения этой проблеммы заключается в следующем, мы можем инкрементировать число и как-то хранить предыдущий результат (число до инкремента) в конечном итоге мы получим пару из n и (n-1).
% Для реализации этого способа, определим упорядоченную пару как тройку термов
% \begin{align*}
% mkPair = \lambda f a b. f a b
% fst = \lambda p. p True
% snd = \lambda p.p False
% \end{align*}
% mkPair создает пару, а fst и snd получают первый и второй элементы пары соответственно.
% Далее определим \"инкремент\" пары
% $succP = \lambda p. mkPair (snd p) (succ (fst p))$
% Ну а имея эту функцию не составит труда определить декремент
% $prev = \lambda n.fst (n succP (mkPair 0 0))$
% и вычитание

\end{document}